import { CANVAS_SIZE } from '../types';

// Helper to pad string to 80 chars for FITS header cards
const padCard = (str: string): string => {
  return str + ' '.repeat(Math.max(0, 80 - str.length));
};

const generateFitsBlob = async (dataUrl: string): Promise<Blob> => {
  return new Promise((resolve) => {
    const img = new Image();
    img.src = dataUrl;
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = CANVAS_SIZE.width;
      canvas.height = CANVAS_SIZE.height;
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        resolve(new Blob([]));
        return;
      }

      // Draw image to canvas to extract pixels
      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, CANVAS_SIZE.width, CANVAS_SIZE.height);
      const data = imageData.data; // RGBA

      // --- 1. Create FITS Header ---
      // Standard FITS Header Unit is 2880 bytes. 
      // Each card is 80 bytes.
      const cards = [
        "SIMPLE  =                    T / file does conform to FITS standard",
        "BITPIX  =                    8 / number of bits per data pixel",
        "NAXIS   =                    2 / number of data axes",
        `NAXIS1  =                   ${CANVAS_SIZE.width} / length of data axis 1`,
        `NAXIS2  =                   ${CANVAS_SIZE.height} / length of data axis 2`,
        "EXTEND  =                    T / FITS dataset may contain extensions",
        "COMMENT   Generated by Dot Animator 200 Web App",
        "END"
      ];

      let headerString = cards.map(padCard).join('');

      // Pad header to multiple of 2880 bytes
      while (headerString.length % 2880 !== 0) {
        headerString += ' ';
      }

      const headerEncoder = new TextEncoder();
      const headerBytes = headerEncoder.encode(headerString);

      // --- 2. Create Data Unit ---
      // FITS data is usually Big Endian, but for BITPIX=8 (byte), endianness doesn't apply.
      // FITS images usually have (0,0) at bottom-left. Canvas is top-left.
      // We must flip the Y-axis.
      
      const pixelCount = CANVAS_SIZE.width * CANVAS_SIZE.height;
      const fileData = new Uint8Array(pixelCount);

      for (let y = 0; y < CANVAS_SIZE.height; y++) {
        for (let x = 0; x < CANVAS_SIZE.width; x++) {
          // Canvas Index (Top-Left origin)
          const sourceIdx = (y * CANVAS_SIZE.width + x) * 4; // *4 for RGBA
          
          // FITS Index (Bottom-Left origin)
          // row 0 is the bottom row
          const targetY = (CANVAS_SIZE.height - 1) - y;
          const targetIdx = targetY * CANVAS_SIZE.width + x;

          // Use Red channel as intensity (Since it's white on black, R=G=B)
          fileData[targetIdx] = data[sourceIdx];
        }
      }

      // Pad data to multiple of 2880 bytes
      const dataSize = fileData.length;
      const paddingSize = (2880 - (dataSize % 2880)) % 2880;
      const finalData = new Uint8Array(dataSize + paddingSize);
      finalData.set(fileData);

      // --- 3. Combine ---
      const blob = new Blob([headerBytes, finalData], { type: 'application/fits' });
      resolve(blob);
    };
  });
};

export const downloadFrames = async (frames: string[]) => {
  // Process sequentially to allow browser to handle multiple downloads
  for (let i = 0; i < frames.length; i++) {
    const blob = await generateFitsBlob(frames[i]);
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = `frame_${i + 1}.fits`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Cleanup
    URL.revokeObjectURL(url);
    
    // Small delay to prevent browser from swallowing subsequent downloads
    await new Promise(r => setTimeout(r, 200));
  }
};

export const createBlankFrame = (): string => {
  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_SIZE.width;
  canvas.height = CANVAS_SIZE.height;
  const ctx = canvas.getContext('2d');
  if (ctx) {
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, CANVAS_SIZE.width, CANVAS_SIZE.height);
  }
  return canvas.toDataURL('image/png');
};